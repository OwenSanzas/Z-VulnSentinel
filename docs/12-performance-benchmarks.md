## 12. 性能基准目标

### 12.1 按项目规模（实测 + 预估）

| 项目规模 | 示例 | SVF（含构建） | Joern（v2） | Introspector（兼容） |
|---------|------|-------------|-------|-------------|
| **小型** (< 50 文件) | libpng (15 .c) | **~30s** (构建 20s + 分析 1.4s) | < 30s | 3-5 min |
| **中型** (50-200 文件) | lcms (75 .c) | **~60s** (构建 40s + 分析 7s) | < 2 min | 5-15 min |
| **大型** (200-1000 文件) | curl (170 .c) | **~3 min** (构建 137s + 分析 73s) | < 10 min | 15-60 min |
| **超大型** (> 1000 文件) | wireshark | 预估 ~10-15 min | < 30 min | > 60 min |

> **注**: SVF 实测数据来自 2025-02 实验。构建时间包含 Docker 内 wllvm 安装 + 项目编译 + llvm-link。

### 12.2 实测调用图规模

| 项目 | SVF 节点数 | SVF 边数 | 从 fuzzer 可达 | SVF 分析耗时 |
|------|-----------|---------|---------------|-------------|
| **libpng** | 641 | 2,325 | ~400 | 1.4s |
| **lcms** | 1,301 | 15,226 | ~900 | 7s |
| **curl** | 2,334 | 18,540 | 2,060 | 73s |

### 12.3 召回率目标（不能漏报）

**核心指标：召回率（Recall）= 被系统发现的真实调用 / 所有真实调用**

| 指标 | SVF（主力） | Joern（降级） |
|------|-----------|-------------|
| **函数提取召回率** | > 99.5% | > 98% |
| **直接调用边召回率** | > 99.9% | > 95% |
| **虚函数分派召回率** | **100%** (CHA + 指针分析) | > 80% (CHA) |
| **函数指针召回率** | **> 95%** (Andersen) | **~0%** (实测断裂) |
| **可达性判断召回率** | **> 99%** | > 70% (因函数指针断裂) |

> **实验验证**: SVF 在 libpng/lcms/curl 上发现了 introspector 遗漏的所有函数指针调用路径（回调注册、类型处理表、协议 handler 表），召回率 100%。

### 12.4 精确率目标（允许一定程度的多报）

**核心原则：宁可多报不能漏报。**

| 指标 | SVF（主力） | Joern（降级） |
|------|-----------|-------------|
| **函数提取精确率** | > 99.9%（只含 binary 中的） | > 80%（含头文件/test 噪声） |
| **直接调用边精确率** | > 99% | > 95% |
| **虚函数分派精确率** | > 60% | > 40% |
| **函数指针精确率** | > 50%* | N/A（不可用） |

\* 函数指针精确率较低是有意为之——Andersen 分析列举所有可能的指向目标以保证召回率

### 12.5 降级链性能-精度权衡

| 后端 | 部署成本 | 精度 | 前置条件 | 适用场景 |
|------|---------|------|---------|---------|
| SVF | 高（Docker + 编译） | 最高 | Docker + 编译成功 | C/C++ 主力 |
| Joern | 中（需安装 joern-cli） | 中（函数指针断裂） | 只需源码 | C/C++ 降级（编译失败时） |

### 12.6 验证方法

- 已在 3 个 OSS-Fuzz C 项目（libpng, lcms, curl）上验证 SVF 后端
- 对比基线: introspector / prebuild 数据中的已知漏洞可达路径
- 指标：函数指针调用路径的发现率（3/3 = 100%）
- 后续计划：在 wireshark（dissector 注册）、mongoose、libxml2 上扩展验证

---
