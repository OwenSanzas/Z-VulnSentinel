# Vuln Sentinel - 企业级漏洞预警系统

## 项目目标

开源库的漏洞从被发现、修复，到 CVE 正式披露，通常存在至少一个月的窗口期。这段时间恰恰是漏洞被利用的高发期——补丁已经公开，攻击者可以逆向分析修复内容，而下游用户尚未意识到风险。

**VulnSentinel 的目标不是缩短 CVE 披露周期，而是在依赖库提交漏洞修复的那一刻，立即分析该漏洞，并检测客户代码中是否存在可被该漏洞影响的调用路径。如果存在，尝试生成 PoC 利用并向客户发出预警。**

## Motivation: 为什么是现在

漏洞预警不是新问题，但过去的自动化手段始终无法突破一个瓶颈：**无法从代码变更中判断"这是不是一个安全修复"。**

传统方法的局限：

- **关键词匹配** — commit message 写了 "buffer overflow" 才能捕获，开发者不写就完全漏掉。大量安全修复的 message 只是 "fix crash" 甚至 "cleanup"。
- **静态规则 / CVE 模式库** — 本质是事后追认，必须等人工审核分配 CVE 编号后才能匹配，天然滞后数周到数月。
- **diff 统计** — 知道改了哪些文件、多少行，但无法理解"为什么改"。一个加了边界检查的 one-liner 和一个无关的 refactor 在统计上没有区别。

这些方法都停留在语法层面，无法回答核心问题：**这个 commit 是在修安全漏洞，还是普通 bug、重构、性能优化？**

LLM 改变了这一点。它能在语义层面理解 diff：

- 看到边界检查被加上 → 可能是 buffer overflow 修复
- 看到 free 后指针被置空 → 可能是 use-after-free 修复
- 看到整数运算加了溢出保护 → 可能是 integer overflow 修复
- 看到输入验证被收紧 → 可能是注入类漏洞修复

这种语义理解能力使得**实时、自动、无需依赖 CVE 披露的漏洞检测**第一次成为可能。

## 核心工作流

```
客户代码 ──→ 提取第三方依赖 ──→ 持续监控依赖库
                                       │
                               依赖库提交 bugfix
                                       │
                                       ▼
                              分析 bugfix 涉及的漏洞（并收集poc， 如果有的话）
                                       │
                                       ▼
                        在客户代码中搜索到达漏洞的调用路径
                                       │
                                       ▼
                              尝试生成 PoC 利用
                                       │
                              ┌────────┴────────┐
                              │                 │
                           可利用            不可利用
                              │                 │
                        预警 + 报告         记录 & 持续监控
```

### 九步流程

| 步骤 | 阶段 | 说明 |
|------|------|------|
| 1 | **客户接入** | 与合作客户建立关系 |
| 2 | **代码托管** | 客户提供代码库访问 |
| 3 | **依赖提取** | 分析客户代码，提取所有第三方库和依赖（zlib、curl、openssl 等） |
| 4 | **依赖监控** | 对所有依赖库建立持续监控（commit feed / release watch） |
| 5 | **Bugfix 检测** | 某个依赖提交了 bugfix 类内容，系统触发警觉 |
| 6 | **漏洞分析** | 分析该 bugfix 的具体漏洞：类型、影响范围、触发条件 |
| 7 | **路径搜索 + 利用** | 在客户代码中寻找从入口到该漏洞的调用路径，尝试生成 PoC |
| 8 | **影响判定** | 若 PoC 成功，确认客户暴露在该漏洞之下 |
| 9 | **预警报告** | 向客户发送预警，包含漏洞详情、影响路径和修复建议 |

## 系统架构

```
┌─────────────────────────────────────────────────────────┐
│                       Frontend                          │
│                  React (Dashboard)                       │
│         客户视图 · 监控面板 · 预警详情 · 报告            │
└────────────────────────┬────────────────────────────────┘
                         │ REST / WebSocket
┌────────────────────────▼────────────────────────────────┐
│                       Backend                           │
│                  FastAPI (API Server)                    │
│      认证 · 任务调度 · 引擎编排 · 推送通知              │
└───────┬────────────────┬────────────────────┬───────────┘
        │                │                    │
        ▼                ▼                    ▼
┌──────────────┐ ┌──────────────┐   ┌──────────────────┐
│   Database   │ │   Engines    │   │     Engines      │
│              │ │  (Python)    │   │    (Python)      │
│ PostgreSQL   │ │              │   │                  │
│ · 客户/项目  │ │ · 依赖监控   │   │ · 静态分析       │
│ · 依赖关系   │ │ · Commit 分析│   │   (z_code_analyzer)│
│ · 漏洞记录   │ │ · 漏洞分类   │   │ · 调用图搜索     │
│ · 分析结果   │ │   (LLM)     │   │ · PoC 生成       │
│ · 预警历史   │ │              │   │   (FuzzingBrain) │
└──────────────┘ └──────────────┘   └──────────────────┘
```

四大层级：

| 层级 | 技术栈 | 职责 |
|------|--------|------|
| **Frontend** | React | 客户 Dashboard，监控状态，预警展示，报告查看 |
| **Backend** | FastAPI | API 网关，认证鉴权，任务调度，引擎编排，WebSocket 推送 |
| **Database** | PostgreSQL | 持久化存储：客户、项目、依赖关系、漏洞、分析结果、预警 |
| **Engines** | Python 模块 | 各独立引擎：依赖监控、commit 语义分析（LLM）、静态分析（z_code_analyzer）、调用图搜索、PoC 生成（FuzzingBrain） |
